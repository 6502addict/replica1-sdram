library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity cache_controller is
    generic (
        CACHE_SIZE_BYTES : integer := 4096;  -- 4KB cache
        LINE_SIZE_BYTES  : integer := 16;    -- 16-byte cache lines
        ADDR_BITS        : integer := 24
    );
    port (
        clk         : in  std_logic;
        reset_n     : in  std_logic;
        
        -- CPU side (upstream)
        cpu_req     : in  std_logic;
        cpu_wr_n    : in  std_logic;
        cpu_addr    : in  std_logic_vector(ADDR_BITS-1 downto 0);
        cpu_din     : in  std_logic_vector(7 downto 0);
        cpu_dout    : out std_logic_vector(7 downto 0);
        cpu_ready   : out std_logic;
        cpu_ack     : out std_logic;
        
        -- Bridge side (downstream) - byte interface
        bridge_req     : out std_logic;
        bridge_wr_n    : out std_logic;
        bridge_addr    : out std_logic_vector(ADDR_BITS-1 downto 0);
        bridge_din     : out std_logic_vector(7 downto 0);
        bridge_dout    : in  std_logic_vector(7 downto 0);
        bridge_ready   : in  std_logic;
        bridge_ack     : in  std_logic;
        
        -- Statistics/debug
        cache_hits     : out unsigned(31 downto 0);
        cache_misses   : out unsigned(31 downto 0);
        cache_evictions : out unsigned(31 downto 0)
    );
end cache_controller;

architecture rtl of cache_controller is

    -- Cache geometry
    constant NUM_LINES      : integer := CACHE_SIZE_BYTES / LINE_SIZE_BYTES;  -- 256 lines
    constant INDEX_BITS     : integer := 8;   -- log2(256)
    constant OFFSET_BITS    : integer := 4;   -- log2(16)
    constant TAG_BITS       : integer := ADDR_BITS - INDEX_BITS - OFFSET_BITS;  -- 12 bits
    
    -- FSM states
    type state_type is (
        IDLE,
        CHECK_TAG,
        HIT_READ,
        HIT_WRITE,
        MISS_EVICT_START,
        MISS_EVICTING,
        MISS_FETCH_START,
        MISS_FETCHING,
        COMPLETE
    );
    signal state : state_type := IDLE;
    
    -- Cache storage in EBR (4KB)
    type cache_line_type is array (0 to LINE_SIZE_BYTES-1) of std_logic_vector(7 downto 0);
    type cache_data_type is array (0 to NUM_LINES-1) of cache_line_type;
    signal cache_data : cache_data_type;
    
    -- Tag storage (256 x 12 bits)
    type tag_array_type is array (0 to NUM_LINES-1) of std_logic_vector(TAG_BITS-1 downto 0);
    signal tag_array : tag_array_type := (others => (others => '0'));
    
    -- Status bits
    signal valid_bits : std_logic_vector(NUM_LINES-1 downto 0) := (others => '0');
    signal dirty_bits : std_logic_vector(NUM_LINES-1 downto 0) := (others => '0');
    
    -- Address breakdown
    signal current_tag    : std_logic_vector(TAG_BITS-1 downto 0);
    signal current_index  : unsigned(INDEX_BITS-1 downto 0);
    signal current_offset : unsigned(OFFSET_BITS-1 downto 0);
    
    -- Working registers
    signal cache_hit      : std_logic;
    signal is_dirty       : std_logic;
    signal is_valid       : std_logic;
    signal byte_counter   : unsigned(OFFSET_BITS-1 downto 0);
    signal line_base_addr : std_logic_vector(ADDR_BITS-1 downto 0);
    signal evict_addr     : std_logic_vector(ADDR_BITS-1 downto 0);
    signal saved_cpu_req  : std_logic;
    signal saved_cpu_wr_n : std_logic;
    signal saved_cpu_din  : std_logic_vector(7 downto 0);
    
    -- Statistics
    signal hits_count      : unsigned(31 downto 0) := (others => '0');
    signal misses_count    : unsigned(31 downto 0) := (others => '0');
    signal evictions_count : unsigned(31 downto 0) := (others => '0');

begin

    -- Output statistics
    cache_hits      <= hits_count;
    cache_misses    <= misses_count;
    cache_evictions <= evictions_count;
    
    -- Address parsing
    current_tag    <= cpu_addr(ADDR_BITS-1 downto INDEX_BITS+OFFSET_BITS);
    current_index  <= unsigned(cpu_addr(INDEX_BITS+OFFSET_BITS-1 downto OFFSET_BITS));
    current_offset <= unsigned(cpu_addr(OFFSET_BITS-1 downto 0));
    
    -- Hit detection
    is_valid   <= valid_bits(to_integer(current_index));
    is_dirty   <= dirty_bits(to_integer(current_index));
    cache_hit  <= '1' when (is_valid = '1' and 
                           tag_array(to_integer(current_index)) = current_tag)
                      else '0';
    
    -- Line base address (zero out offset bits)
    line_base_addr <= cpu_addr(ADDR_BITS-1 downto OFFSET_BITS) & 
                     (OFFSET_BITS-1 downto 0 => '0');
    
    -- Eviction address
    evict_addr <= tag_array(to_integer(current_index)) & 
                  std_logic_vector(current_index) & 
                  (OFFSET_BITS-1 downto 0 => '0');

    -- Main FSM
    process(clk)
    begin
        if rising_edge(clk) then
            if reset_n = '0' then
                state <= IDLE;
                cpu_ready <= '1';
                cpu_ack <= '0';
                bridge_req <= '0';
                valid_bits <= (others => '0');
                dirty_bits <= (others => '0');
                hits_count <= (others => '0');
                misses_count <= (others => '0');
                evictions_count <= (others => '0');
                
            else
                case state is
                    
                    -- ==========================================
                    -- IDLE - Wait for CPU request
                    -- ==========================================
                    when IDLE =>
                        cpu_ready <= '1';
                        cpu_ack <= '0';
                        bridge_req <= '0';
                        
                        if cpu_req = '1' then
                            cpu_ready <= '0';
                            saved_cpu_req <= cpu_req;
                            saved_cpu_wr_n <= cpu_wr_n;
                            saved_cpu_din <= cpu_din;
                            state <= CHECK_TAG;
                        end if;
                    
                    -- ==========================================
                    -- CHECK_TAG - Determine hit or miss
                    -- ==========================================
                    when CHECK_TAG =>
                        if cache_hit = '1' then
                            -- CACHE HIT!
                            hits_count <= hits_count + 1;
                            
                            if saved_cpu_wr_n = '1' then
                                state <= HIT_READ;
                            else
                                state <= HIT_WRITE;
                            end if;
                        else
                            -- CACHE MISS!
                            misses_count <= misses_count + 1;
                            
                            -- Check if need to evict dirty line
                            if is_valid = '1' and is_dirty = '1' then
                                evictions_count <= evictions_count + 1;
                                byte_counter <= (others => '0');
                                state <= MISS_EVICT_START;
                            else
                                -- Clean line or invalid, just fetch
                                byte_counter <= (others => '0');
                                state <= MISS_FETCH_START;
                            end if;
                        end if;
                    
                    -- ==========================================
                    -- HIT_READ - Return data from cache
                    -- ==========================================
                    when HIT_READ =>
                        cpu_dout <= cache_data(to_integer(current_index))(to_integer(current_offset));
                        state <= COMPLETE;
                    
                    -- ==========================================
                    -- HIT_WRITE - Update cache, mark dirty
                    -- ==========================================
                    when HIT_WRITE =>
                        cache_data(to_integer(current_index))(to_integer(current_offset)) <= saved_cpu_din;
                        dirty_bits(to_integer(current_index)) <= '1';
                        state <= COMPLETE;
                    
                    -- ==========================================
                    -- MISS_EVICT_START - Begin dirty line writeback
                    -- ==========================================
                    when MISS_EVICT_START =>
                        if bridge_ready = '1' then
                            bridge_req <= '1';
                            bridge_wr_n <= '0';  -- Write
                            bridge_addr <= std_logic_vector(unsigned(evict_addr) + byte_counter);
                            bridge_din <= cache_data(to_integer(current_index))(to_integer(byte_counter));
                            state <= MISS_EVICTING;
                        end if;
                    
                    -- ==========================================
                    -- MISS_EVICTING - Write cache line bytes
                    -- ==========================================
                    when MISS_EVICTING =>
                        if bridge_ack = '1' then
                            bridge_req <= '0';
                            
                            if byte_counter = LINE_SIZE_BYTES - 1 then
                                -- Eviction complete
                                dirty_bits(to_integer(current_index)) <= '0';
                                byte_counter <= (others => '0');
                                state <= MISS_FETCH_START;
                            else
                                -- Next byte
                                byte_counter <= byte_counter + 1;
                                state <= MISS_EVICT_START;
                            end if;
                        end if;
                    
                    -- ==========================================
                    -- MISS_FETCH_START - Begin line fill from bridge
                    -- ==========================================
                    when MISS_FETCH_START =>
                        if bridge_ready = '1' then
                            bridge_req <= '1';
                            bridge_wr_n <= '1';  -- Read
                            bridge_addr <= std_logic_vector(unsigned(line_base_addr) + byte_counter);
                            state <= MISS_FETCHING;
                        end if;
                    
                    -- ==========================================
                    -- MISS_FETCHING - Fill cache line bytes
                    -- ==========================================
                    when MISS_FETCHING =>
                        if bridge_ack = '1' then
                            bridge_req <= '0';
                            cache_data(to_integer(current_index))(to_integer(byte_counter)) <= bridge_dout;
                            
                            if byte_counter = LINE_SIZE_BYTES - 1 then
                                -- Fetch complete, update tag and valid
                                tag_array(to_integer(current_index)) <= current_tag;
                                valid_bits(to_integer(current_index)) <= '1';
                                dirty_bits(to_integer(current_index)) <= '0';
                                
                                -- Now service the original CPU request
                                if saved_cpu_wr_n = '1' then
                                    state <= HIT_READ;
                                else
                                    state <= HIT_WRITE;
                                end if;
                            else
                                -- Next byte
                                byte_counter <= byte_counter + 1;
                                state <= MISS_FETCH_START;
                            end if;
                        end if;
                    
                    -- ==========================================
                    -- COMPLETE - Signal CPU request done
                    -- ==========================================
                    when COMPLETE =>
                        cpu_ack <= '1';
                        state <= IDLE;
                        
                end case;
            end if;
        end if;
    end process;

end rtl;