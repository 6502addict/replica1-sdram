-- ============================================================================
-- CPU_65C02.vhd
-- ============================================================================

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

entity CPU_R65C02 is
	port (
		-- Clock and Reset
		sdram_clk : in  std_logic;
		main_clk  : in  std_logic;        -- Main system clock
		reset_n   : in  std_logic;        -- Active low reset
		phi2      : out std_logic;        -- Phase 2 clock enable
		phi1      : out std_logic;        -- Phase 1 clock 
		
		-- CPU Control Interface
		rw        : out std_logic;        -- Read/Write (1=Read, 0=Write)
		vma       : out std_logic;        -- Valid Memory Access
		sync      : out std_logic;        -- Instruction fetch cycle
		
		-- Address and Data Bus
		addr      : out std_logic_vector(15 downto 0);  -- Address bus
		data_in   : in  std_logic_vector(7 downto 0);   -- Data input
		data_out  : out std_logic_vector(7 downto 0);   -- Data output
		
		-- Interrupt Interface   
		nmi_n     : in  std_logic;        -- Non-maskable interrupt (active low)
		irq_n     : in  std_logic;        -- Interrupt request (active low)
		so_n      : in  std_logic := '1'; -- Set overflow (active low)
		
		-- wait states
		mrdy      : in  std_logic;
		strch     : out std_logic;
		bshit     : out std_logic
	);
end CPU_R65C02;

architecture CPU_R65C02_impl of CPU_R65C02 is

	component M6809_Clock_Gen is
		 Port (
			  clk_4x : in  STD_LOGIC;  -- Input clock (4x frequency)
			  reset  : in  STD_LOGIC;  -- Asynchronous reset
			  mrdy   : in  STD_LOGIC;  -- Memory Ready (Low = Stretch Clocks)
			  E      : out STD_LOGIC;  -- Enable clock
			  Q      : out STD_LOGIC   -- Quadrature clock
		 );
	end component;

	component R65C02 is
		port (
			
			reset : in std_logic;
			clk : in std_logic;
			enable : in std_logic;
			nmi_n : in std_logic;
			irq_n : in std_logic;
			di : in unsigned(7 downto 0);
			do : out unsigned(7 downto 0);
			do_next : out unsigned(7 downto 0);
			addr : out unsigned(15 downto 0);
			addr_next : out unsigned(15 downto 0);
			nwe : out std_logic;
			nwe_next : out std_logic;
			sync : out std_logic;
			sync_irq : out std_logic
				
		);
	end component;	

	-- Internal signals
	signal data_bus      : std_logic_vector(7 downto 0);
	signal address_bus   : std_logic_vector(15 downto 0);
	signal cpu_data_out  : std_logic_vector(7 downto 0);
	signal rw_internal   : std_logic;
	signal sync_internal : std_logic;
	signal vma_internal  : std_logic;
	signal phi2_internal : std_logic;

	-- CPU65XX specific signals
	signal r6502_do    : unsigned(7 downto 0);
	signal r6502_addr  : unsigned(15 downto 0);
	signal r6502_we    : std_logic;
	
   signal stretched_clk : std_logic;
	signal hold_clock    : std_logic := '0';
	signal xclock        : std_logic := '0';

begin

	-- Input data bus assignment
	data_bus <= data_in;
	phi2     <= phi2_internal;

	process(main_clk, mrdy)
	begin
		 if main_clk = '1' then
			  hold_clock <= not mrdy;
		 end if;
	end process;

	stretched_clk <= main_clk or hold_clock;
	
	clock: M6809_Clock_Gen port map(clk_4x => stretched_clk, 
											  reset  => not reset_n,
			                          mrdy   => '1',
			                          E      => phi2_internal,
			                          Q      => phi1);
											  
	process(stretched_clk)
	begin
	if falling_edge(stretched_clk) then
		xclock <= not xclock;
	end if;
	end process;
											  
											  
	-- R65C02 instantiation
	cpu65c02_inst: R65C02
		port map (
			reset     => not reset_n,
			clk       => xclock,
			enable    => not phi2_internal,
			nmi_n     => nmi_n,
			irq_n     => irq_n,
			di        => unsigned(data_bus),
			do        => r6502_do,
			do_next   => open,
			addr      => r6502_addr,
			addr_next => open,
			nwe       => r6502_we,
			nwe_next  => open,
			sync      => sync,
			sync_irq  => open
		);
		
	-- Signal assignments for R6502
	cpu_data_out  <= std_logic_vector(r6502_do);
	address_bus   <= std_logic_vector(r6502_addr);
	rw_internal   <= not r6502_we  ;              -- Convert WE to RW
	sync_internal <= '0';                         -- CPU65XX doesn't have sync
	vma_internal  <= '1';                         -- on a 6502 the addresses are valid when phi2 is high

	-- Output assignments
	addr     <= address_bus;
	data_out <= cpu_data_out;
	rw       <= rw_internal;
	sync     <= sync_internal;
	vma      <= vma_internal;

end CPU_R65C02_impl;