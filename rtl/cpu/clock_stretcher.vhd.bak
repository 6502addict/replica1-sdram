library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity clock_stretcher is
    generic (
        DIVIDER : integer := 4  -- Clock divider (4 = input/4)
    );
    port (
        clk_in         : in  std_logic;  -- Fast input clock (e.g., 8MHz)
        reset          : in  std_logic;  -- Active high reset
        mrdy           : in  std_logic;  -- Memory ready (1=ready, 0=stretch)
		  stretch_active : out std_logic;
        clk_out        : out std_logic   -- Stretched output clock (e.g., 2MHz)
    );
end entity;

architecture rtl of clock_stretcher is
    signal counter    : integer range 0 to DIVIDER-1 := 0;
    signal clk_toggle : std_logic := '0';
    signal clk_high   : std_logic := '0';
begin

  	 stretch_active <= '1' when (clk_toggle = '1' and mrdy = '0') else '0';
 
    clk_out <= clk_toggle;

    process(clk_in)
    begin
        if rising_edge(clk_in) then
            if reset = '1' then
                counter    <= 0;
                clk_toggle <= '0';
                clk_high   <= '0';
                
            else
                -- Only count when memory is ready OR clock is low
                if mrdy = '1' or clk_toggle = '0' then
                    if counter = DIVIDER-1 then
                        counter    <= 0;
                        clk_toggle <= not clk_toggle;
                        clk_high   <= not clk_toggle;  -- Track high phase
                    else
                        counter <= counter + 1;
                    end if;
                end if;
                -- When mrdy=0 during high phase: freeze counter, hold clock high
            end if;
        end if;
    end process;

end rtl;