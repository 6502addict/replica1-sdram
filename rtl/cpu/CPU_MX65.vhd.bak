-- ============================================================================
-- CPU_MX65.vhd
-- Derived from Apple1_CPU_Template.vhd
-- 
-- CPU: MX65 (Steve Teal's 6502 implementation)
-- Dependencies: mx65 core
-- ============================================================================

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

entity CPU_MX65 is
	port (
		-- Clock and Reset
		sdram_clk : in  std_logic;
		main_clk  : in  std_logic;        -- Main system clock (2x CPU)
		reset_n   : in  std_logic;        -- Active low reset
		phi2      : out std_logic;        -- Phase 2 clock (valid data window)
		phi1      : out std_logic;        -- Phase 1 clock
		
		-- CPU Control Interface
		rw        : out std_logic;        -- Read/Write (1=Read, 0=Write)
		vma       : out std_logic;        -- Valid Memory Access
		sync      : out std_logic;        -- Instruction fetch cycle
		
		-- Address and Data Bus
		addr      : out std_logic_vector(15 downto 0);
		data_in   : in  std_logic_vector(7 downto 0);
		data_out  : out std_logic_vector(7 downto 0);
		
		-- Interrupt Interface   
		nmi_n     : in  std_logic;        -- Non-maskable interrupt (active low)
		irq_n     : in  std_logic;        -- Interrupt request (active low)
		so_n      : in  std_logic := '1'; -- Set overflow (active low) - not used by MX65
		
		-- wait states
		mrdy      : in  std_logic;        -- Memory Ready (Low = stretch clock)
		strch     : out std_logic;        -- Stretched clock status
		bshit     : out std_logic
	);
end CPU_MX65;

architecture CPU_MX65_impl of CPU_MX65 is

	component mx65 port (
		clock	: in  std_logic;
		reset	: in  std_logic;	  
		ce		: in  std_logic;
		data_in	: in  std_logic_vector(7 downto 0);
		data_out: out std_logic_vector(7 downto 0);
		address	: out std_logic_vector(15 downto 0);
		rw		: out std_logic;
		sync	: out std_logic;
		nmi		: in  std_logic;
		irq		: in  std_logic);
	end component;

	-- P1 = clock enable (clock/2), gated by mrdy
	-- P2 = P1 delayed by 1 tick = valid data window (PHI2 equivalent)
	signal p1           : std_logic := '0';
	signal p2           : std_logic := '0';

begin

	-- P1/P2 generation with mrdy clock stretching
	-- When mrdy='0', p1 is held low -> CPU frozen
	-- When mrdy='1', p1 toggles normally
	process(main_clk, reset_n)
	begin
		if reset_n = '0' then
			p1 <= '0';
			p2 <= '0';
		elsif rising_edge(main_clk) then
			if p1 = '1' then
				p1 <= '0';          -- always complete the enable pulse
			else
				p1 <= mrdy;         -- only start new pulse if ready
			end if;
			p2 <= p1;
		end if;
	end process;

	-- MX65 instantiation
	-- nmi/irq are active high on mx65
	cpu: mx65 port map(
		clock    => main_clk,
		reset    => not reset_n,
		ce       => p1,
		data_in  => data_in,
		data_out => data_out,
		address  => addr,
		rw       => rw,
		sync     => sync,
		nmi      => not nmi_n,
		irq      => not irq_n
	);

	-- Output assignments
	phi1  <= p1;
	phi2  <= p2;
	vma   <= '1';                   -- on a 6502 addresses are valid when phi2 is high
	strch <= not mrdy;              -- '1' when clock is being stretched
	bshit <= '0';

end CPU_MX65_impl;