-- ============================================================================
-- Apple1_CPU_T65.vhd
-- Derived from Apple1_CPU_Template.vhd
-- 
-- CPU: T65 (FPGA-optimized 6502 core)
-- Dependencies: T65_Pack package
-- https://opencores.org/projects/t65
-- ============================================================================

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;
use work.T65_Pack.all;      -- Required for T65 CPU

entity Apple1_CPU is
	port (
		-- Clock and Reset
		main_clk : in  std_logic;       -- Main system clock
		reset_n  : in  std_logic;       -- Active low reset
		phi2     : out std_logic;       -- Phase 2 clock enable
		
		-- CPU Control Interface
		rw       : out std_logic;       -- Read/Write (1=Read, 0=Write)
		vma      : out std_logic;       -- Valid Memory Access
		sync     : out std_logic;       -- Instruction fetch cycle
		
		-- Address and Data Bus
		addr     : out std_logic_vector(15 downto 0);  -- Address bus
		data_in  : in  std_logic_vector(7 downto 0);   -- Data input
		data_out : out std_logic_vector(7 downto 0);   -- Data output
		
		-- Interrupt Interface  
		nmi_n    : in  std_logic;       -- Non-maskable interrupt (active low)
		irq_n    : in  std_logic;       -- Interrupt request (active low)
		so_n     : in  std_logic := '1' -- Set overflow (active low)
	);
end Apple1_CPU;

architecture T65_impl of Apple1_CPU is

	component clock_divider is
		 generic (divider : integer := 4);
		 port (
			  reset    : in  std_logic := '1';
			  clk_in   : in  std_logic;
			  clk_out  : out std_logic
		 );
	end component;


	-- Internal signals
	signal data_bus      : std_logic_vector(7 downto 0);
	signal address_bus   : std_logic_vector(15 downto 0);
	signal cpu_data_out  : std_logic_vector(7 downto 0);
	signal rw_internal   : std_logic;
	signal sync_internal : std_logic;
	signal vma_internal  : std_logic;
	signal phi2_internal : std_logic;

	-- T65 specific signals  
	signal t65_addr      : std_logic_vector(23 downto 0);
	signal t65_rw_n      : std_logic;

begin

	-- Input data bus assignment
	data_bus <= data_in;
	phi2     <= phi2_internal;
	
	clk:  clock_divider generic map(divider         => 2)  
								  port map(reset           => '1',
									  	     clk_in          => main_clk,
											  clk_out         => phi2_internal);	
	
	-- T65 Instantiation
	t65_inst: work.T65 
		port map(
			Mode    => "00",                        -- 6502 mode
			BCD_en  => '1',                         -- Enable BCD mode
			Res_n   => reset_n,                     -- T65 uses active low reset
			Enable  => phi2_internal,
			Clk     => main_clk,
			Rdy     => '1',                         -- Always ready
			Abort_n => '1',                         -- No abort
			IRQ_n   => irq_n,
			NMI_n   => nmi_n,
			SO_n    => so_n,
			R_W_n   => t65_rw_n,
			Sync    => sync_internal,
			EF      => open,
			MF      => open,
			XF      => open, 
			ML_n    => open, 
			VP_n    => open,
			VDA     => open,
			VPA     => open,
			A       => t65_addr,
			DI      => data_bus,
			DO      => cpu_data_out,
			Regs    => open,
			DEBUG   => open,
			NMI_ack => open
		);
		
	-- Signal assignments for T65
	address_bus   <= t65_addr(15 downto 0);       -- Use lower 16 bits
	rw_internal   <= t65_rw_n;                    -- T65 outputs inverted RW
	vma_internal  <= phi2_internal;               -- on a 6502 addresses are valid when phi2 is high

	-- Output assignments
	addr     <= address_bus;
	data_out <= cpu_data_out;
	rw       <= rw_internal;
	sync     <= sync_internal;
	vma      <= vma_internal;

end T65_impl;